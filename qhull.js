// Generated by CoffeeScript 1.7.1
(function() {
  var $settings, Face, FaceLink, QuickhullSolver, SHOW_STATS, Tracer, addSetting, animate, assignPoints, checkFace, checkHorizon, checkHull, config, init, isFace, isVector, lastKey, makePoints, onKeyDown, onMouseWheel, random, render, reset, seed;

  SHOW_STATS = false;

  if (!Detector.webgl) {
    Detector.addWebGLMessage();
  }

  init = function() {
    var bgColor, camera, container, controls, onWindowResize, renderer, scene, sceneRoot, stats;
    bgColor = 0xeeeeee;
    container = document.getElementById('container');
    camera = camera = new THREE.PerspectiveCamera(27, window.innerWidth / window.innerHeight, 5, 3500);
    camera.position.z = 2750;
    scene = new THREE.Scene;
    scene.fog = new THREE.Fog(bgColor, 2000, 4000);
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
    renderer.setClearColor(bgColor, 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    if (SHOW_STATS) {
      stats = new Stats;
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.top = '0px';
      stats.domElement.style.right = '0px';
      container.appendChild(stats.domElement);
    }
    onWindowResize = function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      return renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', onWindowResize, false);
    sceneRoot = new THREE.Object3D;
    scene.add(sceneRoot);
    controls = new THREE.OrbitControls(camera);
    controls.noKeys = true;
    controls.noZoom = true;
    controls.noPan = true;
    window.sceneRoot = sceneRoot;
    window.renderer = renderer;
    window.camera = camera;
    window.controls = controls;
    window.scene = scene;
    return window.stats = stats;
  };

  init();

  animate = function() {
    var _ref;
    requestAnimationFrame(animate);
    render();
    return (_ref = window.stats) != null ? _ref.update() : void 0;
  };

  render = function() {
    return window.renderer.render(window.scene, window.camera);
  };

  window.controls.addEventListener('change', render);

  isVector = function(a) {
    return a instanceof THREE.Vector3;
  };

  isFace = function(t) {
    return t instanceof Face;
  };

  Tracer = (function() {
    var COLOR_EDGE_END, COLOR_EDGE_START, MATERIAL_ARROW, MATERIAL_FACE_HIGHLIGHT, MATERIAL_FACE_INNER, MATERIAL_FACE_OUTER, MATERIAL_FACE_WIRE, MATERIAL_LINE, MATERIAL_PARTICLE_DEFAULT, MATERIAL_PARTICLE_RED;

    COLOR_EDGE_START = new THREE.Color(0xff0000);

    COLOR_EDGE_END = new THREE.Color(0x0000ff);

    MATERIAL_PARTICLE_DEFAULT = new THREE.ParticleBasicMaterial({
      color: 0x0000ff,
      size: 40
    });

    MATERIAL_PARTICLE_RED = new THREE.ParticleBasicMaterial({
      color: 0xff0000,
      size: 80
    });

    MATERIAL_ARROW = new THREE.MeshBasicMaterial({
      color: 0xff0000
    });

    MATERIAL_FACE_OUTER = new THREE.MeshBasicMaterial({
      color: 0xffff00,
      transparent: true,
      opacity: .5
    });

    MATERIAL_FACE_INNER = new THREE.MeshBasicMaterial({
      color: 0xff0088,
      transparent: true,
      opacity: .5,
      side: THREE.BackSide
    });

    MATERIAL_FACE_HIGHLIGHT = new THREE.MeshBasicMaterial({
      color: 0xffff00,
      transparent: true,
      opacity: .75
    });

    MATERIAL_FACE_WIRE = new THREE.MeshBasicMaterial({
      color: 0x888888,
      transparent: true,
      opacity: .5,
      wireframe: true,
      depthTest: false
    });

    MATERIAL_LINE = new THREE.LineBasicMaterial({
      linewidth: 4,
      vertexColors: THREE.VertexColors
    });

    function Tracer() {
      this.scenes = [];
      this.index = 0;
      this.$subtitle = $('#subtitle');
      this.$el = $('#trace');
      this.$el.empty();
      this.$el.css({
        position: 'absolute',
        bottom: '1em',
        top: '0em',
        left: '1em',
        overflow: 'hidden'
      });
    }

    Tracer.prototype.getVertices = function(vertices, options) {
      var g, m, _ref;
      if (options == null) {
        options = {};
      }
      if (!_.all(vertices, isVector)) {
        console.error("invalid vertex");
        return;
      }
      m = options.material || MATERIAL_PARTICLE_DEFAULT;
      g = new THREE.Geometry;
      (_ref = g.vertices).push.apply(_ref, vertices);
      return new THREE.ParticleSystem(g, m);
    };

    Tracer.prototype.getEdges = function(edges, options) {
      var obj;
      if (options == null) {
        options = {};
      }
      if (!_.all(edges, function(_arg) {
        var a, b;
        a = _arg.a, b = _arg.b;
        return isVector(a) && isVector(b);
      })) {
        console.error("invalid edge");
        return;
      }
      obj = new THREE.Object3D;
      edges.forEach(function(_arg, i) {
        var a, b, cA, cB, g;
        a = _arg.a, b = _arg.b;
        g = new THREE.Geometry;
        cA = COLOR_EDGE_START.clone().lerp(COLOR_EDGE_END, i / edges.length);
        cB = COLOR_EDGE_START.clone().lerp(COLOR_EDGE_END, (i + 1) / edges.length);
        g.vertices.push(a, b);
        g.colors.push(cA, cB);
        return obj.add(new THREE.Line(g, MATERIAL_LINE));
      });
      return obj;
    };

    Tracer.prototype.getFaces = function(faces, options) {
      var g, matInner, matOuter, matWire, obj;
      if (options == null) {
        options = {};
      }
      if (!_.all(faces, isFace)) {
        console.error("invalid face");
        return;
      }
      matOuter = options.materialOuter || MATERIAL_FACE_OUTER;
      matInner = options.materialInner || MATERIAL_FACE_INNER;
      matWire = options.materialWire || MATERIAL_FACE_WIRE;
      g = new THREE.Geometry;
      _.filter(faces, function(f) {
        return !f.deleted;
      }).forEach(function(f) {
        var n;
        if (f.deleted) {
          throw new Error("deleted face!");
        }
        n = g.vertices.length;
        g.vertices.push(f.a, f.b, f.c);
        return g.faces.push(new THREE.Face3(n, n + 1, n + 2));
      });
      obj = new THREE.Object3D;
      obj.add(new THREE.Mesh(g, matOuter));
      obj.add(new THREE.Mesh(g, matInner));
      obj.add(new THREE.Mesh(g, matWire));
      return obj;
    };

    Tracer.prototype.trace = function(message, options) {
      var $el, edges, faces, hiEdges, hiFaces, hiVertices, obj, subtitle, vertices;
      obj = new THREE.Object3D;
      vertices = options.vertices, edges = options.edges, faces = options.faces, hiVertices = options.hiVertices, hiEdges = options.hiEdges, hiFaces = options.hiFaces, subtitle = options.subtitle;
      if (vertices) {
        obj.add(this.getVertices(_.difference(vertices, hiVertices || [])));
      }
      if (edges) {
        obj.add(this.getEdges(_.difference(edges, hiEdges || [])));
      }
      if (faces) {
        obj.add(this.getFaces(_.difference(faces, hiFaces || [])));
      }
      if (hiVertices) {
        obj.add(this.getVertices(hiVertices, {
          material: MATERIAL_PARTICLE_RED
        }));
      }
      if (hiFaces) {
        obj.add(this.getFaces(hiFaces, {
          materialOuter: MATERIAL_FACE_HIGHLIGHT
        }));
      }
      $el = $("<div>").append($("<span>").text("" + this.scenes.length + ". " + message));
      $el.css({
        color: '#888'
      });
      this.$el.append($el);
      this.scenes.push({
        message: message,
        obj: obj,
        $el: $el,
        subtitle: subtitle
      });
      if (this.scenes.length === 2) {
        this.index = 0;
        return this.showScene();
      }
    };

    Tracer.prototype.showNext = function() {
      if (this.index < this.scenes.length - 1) {
        this.index += 1;
        return this.showScene();
      }
    };

    Tracer.prototype.showPrev = function() {
      if (this.index > 0) {
        this.index -= 1;
        return this.showScene();
      }
    };

    Tracer.prototype.showFirst = function() {
      this.index = 0;
      return this.showScene();
    };

    Tracer.prototype.showLast = function() {
      this.index = this.scenes.length - 1;
      return this.showScene();
    };

    Tracer.prototype.hideScene = function() {
      if (this.s) {
        window.sceneRoot.remove(this.s.obj);
        this.s.$el.css({
          color: '#888'
        });
        return this.s.$el.find(".subtitle").hide();
      }
    };

    Tracer.prototype.showScene = function() {
      this.hideScene();
      this.s = this.scenes[this.index];
      if (this.s) {
        window.sceneRoot.add(this.s.obj);
        this.s.$el.css({
          color: '#444'
        });
        this.$subtitle.html(this.s.subtitle || "");
        return this.scenes[Math.max(this.index - 10, 0)].$el.get(0).scrollIntoView();
      }
    };

    Tracer.prototype.clear = function() {
      return this.hideScene();
    };

    return Tracer;

  })();

  config = {
    TRACE_INITIAL: true,
    TRACE_HORIZON: true,
    TRACE_MANY_HORIZON_PATHS: false,
    TRACE_HORIZON_STEP: false,
    TRACE_TERMINATE: false,
    TRACE_NEW_FACE_EACH: false,
    TRACE_NEW_FACES: true
  };

  FaceLink = (function() {
    function FaceLink(face, a, b) {
      this.a = a;
      this.b = b;
      this.from = face;
      this.to = null;
    }

    FaceLink.prototype.reverseOf = function(_arg) {
      var a, b;
      a = _arg.a, b = _arg.b;
      return (this.a === b) && (this.b === a);
    };

    return FaceLink;

  })();

  Face = (function() {
    function Face(a, b, c) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.triangle = new THREE.Triangle(a, b, c);
      this.plane = this.triangle.plane();
      this.links = [this.linkAB = new FaceLink(this, this.a, this.b), this.linkBC = new FaceLink(this, this.b, this.c), this.linkCA = new FaceLink(this, this.c, this.a)];
      this.assignedPoints = [];
      this.furthest = {
        point: null,
        distance: -Infinity
      };
      this.deleted = false;
      this.visited = false;
    }

    Face.prototype.hasPoint = function(point) {
      return (point === this.a) || (point === this.b) || (point === this.c);
    };

    Face.prototype.distance = function(point) {
      if (this.hasPoint(point)) {
        return 0;
      } else {
        return this.plane.distanceToPoint(point);
      }
    };

    Face.prototype.normalLine = function() {
      var m, n;
      m = this.triangle.midpoint();
      n = this.triangle.midpoint().add(this.triangle.normal().normalize().multiplyScalar(50));
      return {
        a: m,
        b: n
      };
    };

    Face.prototype.visibleBy = function(point) {
      return this.hasPoint(point) || (this.distance(point) > 0);
    };

    Face.prototype.connect = function(otherFace, link, otherLink) {
      if (!link.reverseOf(otherLink)) {
        throw new Error("can't connect with non-reverse link");
      }
      link.to = otherFace;
      otherLink.to = this;
      link.inverse = otherLink;
      return otherLink.inverse = link;
    };

    Face.prototype.assign = function(point) {
      var d;
      if (this.hasPoint(point)) {
        return true;
      } else {
        d = this.distance(point);
        if (d >= 0) {
          this.assignedPoints.push(point);
          if (d > this.furthest.distance) {
            this.furthest.distance = d;
            this.furthest.point = point;
          }
          return true;
        } else {
          return false;
        }
      }
    };

    return Face;

  })();

  assignPoints = function(faces, points) {
    return points.forEach(function(p) {
      return _.any(faces, function(f) {
        return f.assign(p);
      });
    });
  };

  checkFace = function(f) {
    var error, setError;
    error = false;
    setError = function(msg) {
      console.log(msg);
      return error = true;
    };
    if (f.deleted) {
      return;
    }
    f.links.forEach(function(l, j) {
      var backLinks, str;
      str = "f.links[" + j + "]";
      if (l.horizon === true) {
        setError("" + str + ".horizon == true");
      }
      if (l.from !== f) {
        setError("" + str + ".from != f");
      }
      if (l.inverse.to !== f) {
        setError("" + str + ".inverse.to != f");
      }
      if (l.inverse.a !== l.b) {
        setError("" + str + ".inverse.a != l.b");
      }
      if (l.inverse.b !== l.a) {
        setError("" + str + ".inverse.b != l.a");
      }
      backLinks = _.pluck(l.to.links, 'to');
      if (!_.contains(backLinks, f)) {
        return setError("no reflexive link", f, backLinks);
      }
    });
    if (error) {
      throw new Error("checkFace failed");
    }
  };

  checkHorizon = function(horizon) {
    return _.every(_.map(horizon, function(h, i) {
      var next;
      next = horizon[(i + 1) % horizon.length];
      if (h.b !== next.a) {
        console.error("discontinuous horizon", h, next);
        return false;
      } else {
        return true;
      }
    }));
  };

  checkHull = function(tracer, hull, points) {
    var valid;
    valid = true;
    _.each(hull, function(f) {
      return _.each(points, function(p) {
        if (visible(face, point)) {
          valid = false;
          return tracer.trace("OUTSIDE POINT", {
            faces: [face],
            vertices: [point]
          });
        }
      });
    });
    return valid;
  };

  QuickhullSolver = (function() {
    function QuickhullSolver(tracer) {
      this.tracer = tracer;
      this.hull = [];
    }

    QuickhullSolver.prototype.getInitialPoints = function(points) {
      var cartesian, extremes, getattr, m1, m2, m3, pointsCopy, removeFromPoints, _ref;
      getattr = function(a) {
        return function(p) {
          return p[a];
        };
      };
      pointsCopy = _.clone(points);
      extremes = [];
      removeFromPoints = function(point) {
        pointsCopy = _.without(pointsCopy, point);
        return point;
      };
      extremes.push(removeFromPoints(_.min(pointsCopy, getattr('x'))));
      extremes.push(removeFromPoints(_.min(pointsCopy, getattr('y'))));
      extremes.push(removeFromPoints(_.min(pointsCopy, getattr('z'))));
      extremes.push(removeFromPoints(_.max(pointsCopy, getattr('x'))));
      extremes.push(removeFromPoints(_.max(pointsCopy, getattr('y'))));
      extremes.push(removeFromPoints(_.max(pointsCopy, getattr('z'))));
      cartesian = _.flatten(_.map(extremes, function(p1) {
        return _.map(extremes, function(p2) {
          return [p1, p2];
        });
      }), true);
      _ref = _.max(cartesian, function(_arg) {
        var p1, p2;
        p1 = _arg[0], p2 = _arg[1];
        return p1.distanceTo(p2);
      }), m1 = _ref[0], m2 = _ref[1];
      m3 = _.max(extremes, function(p3) {
        var q;
        q = p3.clone().sub(m1);
        return q.cross(m2).length();
      });
      return [m1, m2, m3];
    };

    QuickhullSolver.prototype.getHull = function(points) {
      var a, b, c, f, face, g, newFaces, stack, _ref;
      this.tracer.trace("quickhull start", {
        vertices: points,
        subtitle: $('#instructions').html()
      });
      _ref = this.getInitialPoints(points), a = _ref[0], b = _ref[1], c = _ref[2];
      f = new Face(a, b, c);
      g = new Face(a, c, b);
      assignPoints([f, g], points);
      f.connect(g, f.linkAB, g.linkCA);
      f.connect(g, f.linkBC, g.linkBC);
      f.connect(g, f.linkCA, g.linkAB);
      this.hull = [f, g];
      if (config.TRACE_INITIAL) {
        this.tracer.trace("initial hull with normals", {
          faces: this.hull,
          edges: _.map(this.hull, function(f) {
            return f.normalLine();
          }),
          vertices: points,
          hiVertices: [a, b, c]
        });
      }
      this.hull.forEach(checkFace);
      stack = [g, f];
      while (face = stack.shift()) {
        if (!face.deleted) {
          newFaces = this.expandHull(face);
          stack.push.apply(stack, newFaces);
        }
      }
      if (checkHull(this.hull, points)) {
        console.log("checkHull successful");
      }
      return this.hull;
    };

    QuickhullSolver.prototype.expandHull = function(face) {
      var d, horizon, newFaces, prev, totalFaces, visited, _ref, _ref1;
      if (_.isEmpty(face.assignedPoints)) {
        return;
      }
      d = face.furthest.point;
      _ref = this.getHorizon(face, d), horizon = _ref.horizon, visited = _ref.visited;
      if (!checkHorizon(horizon)) {
        throw new Error("invalid horizon");
      }
      if (config.TRACE_HORIZON) {
        this.tracer.trace("expand hull", {
          faces: visited,
          edges: horizon,
          vertices: face.assignedPoints,
          hiVertices: [d],
          subtitle: "" + visited.length + " faces visible from furthest point"
        });
      }
      newFaces = [];
      prev = null;
      horizon.forEach((function(_this) {
        return function(link) {
          var a, b, f;
          link.horizon = false;
          a = link.a, b = link.b;
          f = new Face(a, b, d);
          f.connect(link.to, f.linkAB, link.inverse);
          if (prev) {
            prev.connect(f, prev.linkBC, f.linkCA);
          }
          prev = f;
          return newFaces.push(f);
        };
      })(this));
      prev.connect(newFaces[0], prev.linkBC, newFaces[0].linkCA);
      visited.forEach(function(f) {
        assignPoints(newFaces, f.assignedPoints);
        f.assignedPoints = [];
        return f.deleted = true;
      });
      if (config.TRACE_NEW_FACE_EACH) {
        newFaces.forEach(function(f) {
          return this.tracer.trace("new face", {
            faces: [f],
            vertices: f.assignedPoints,
            edges: [f.linkAB],
            hiVertices: [d],
            subtitle: "new face from found horizon edge to furthest point,\n" + f.assignedPoints.length + " assigned points"
          });
        });
      }
      if (config.TRACE_NEW_FACES) {
        this.tracer.trace("new faces", {
          vertices: [d],
          edges: horizon,
          faces: newFaces,
          subtitle: "" + newFaces.length + " new faces along the found horizon"
        });
      }
      (_ref1 = this.hull).push.apply(_ref1, newFaces);
      totalFaces = _.filter(this.hull, function(h) {
        return !h.deleted;
      });
      this.tracer.trace("new hull", {
        faces: this.hull,
        hiFaces: newFaces,
        vertices: points,
        subtitle: "" + totalFaces.length + " total hull faces"
      });
      this.hull.forEach(checkFace);
      return newFaces;
    };

    QuickhullSolver.prototype.getHorizon = function(face, point) {
      var addHorizon, f, horizon, horizonPaths, mergePaths, p, stack, visited;
      stack = [face];
      visited = [];
      horizon = [];
      mergePaths = function(path, links) {
        var linkEnd, linkStart, pathEnd, pathStart;
        if (path.length === 0) {
          path.push.apply(path, links);
          return true;
        }
        pathStart = _.first(path).a;
        pathEnd = _.last(path).b;
        linkStart = _.first(links).a;
        linkEnd = _.last(links).b;
        if (linkStart === pathEnd) {
          path.push.apply(path, links);
        } else if (linkEnd === pathStart) {
          path.unshift.apply(path, links);
        } else {
          return false;
        }
        return true;
      };
      horizonPaths = [];
      addHorizon = (function(_this) {
        return function(link) {
          if (!_.some(horizonPaths, function(path) {
            return mergePaths(path, [link]);
          })) {
            horizonPaths.push([link]);
          }
          if (config.TRACE_HORIZON_STEP) {
            _this.tracer.trace("found horizon edge", {
              faces: [link.from, link.to],
              edges: [link],
              vertices: [point],
              subtitle: 'boundary between visible and invisible face'
            });
          }
          if (config.TRACE_MANY_HORIZON_PATHS) {
            if (horizonPaths.length > 2) {
              return horizonPaths.forEach(function(links, i) {
                return this.tracer.trace("horizon path " + i, {
                  faces: _.map(links, function(l) {
                    return l.from;
                  }),
                  edges: links
                });
              });
            }
          }
        };
      })(this);
      while (f = stack.pop()) {
        f.visited = true;
        visited.push(f);
        f.links.forEach((function(_this) {
          return function(l, i) {
            l.horizon = !l.to.visibleBy(point);
            if (l.horizon) {
              return addHorizon(l);
            } else {
              if (!l.to.visited) {
                stack.push(l.to);
                return l.to.visited = true;
              }
            }
          };
        })(this));
      }
      visited.forEach(function(f) {
        return f.visited = false;
      });
      horizon = [];
      while (p = horizonPaths.pop()) {
        mergePaths(horizon, p);
      }
      return {
        horizon: horizon,
        visited: visited
      };
    };

    return QuickhullSolver;

  })();

  makePoints = function(random, n) {
    var points, s, vector, _i;
    s = 200.0;
    points = [];
    for (_i = 0; 0 <= n ? _i <= n : _i >= n; 0 <= n ? _i++ : _i--) {
      while (!((vector != null ? vector.length() : void 0) < 3)) {
        vector = new THREE.Vector3(random.gauss(), random.gauss(), random.gauss());
      }
      points.push(vector.multiplyScalar(s));
    }
    return points;
  };

  seed = null;

  if (seed === null) {
    seed = (Math.random() * 10000).toFixed(0);
  }

  console.log("seed", seed);

  random = new Random;

  random.seed(seed);

  window.points = makePoints(random, 1000);

  animate();

  reset = function(seed) {
    if (seed) {
      random.seed(seed);
    }
    window.points = makePoints(random, 100);
    if (window.tracer) {
      window.tracer.clear();
    }
    window.tracer = new Tracer;
    window.solver = new QuickhullSolver(window.tracer);
    return window.solver.getHull(window.points);
  };

  $settings = $("#settings");

  addSetting = function(description, key) {
    var $checkbox, $el, changeKey;
    changeKey = function(key, value) {
      config[key] = value;
      return reset(seed);
    };
    $checkbox = $("<input>", {
      type: "checkbox"
    }).on('change', function(e) {
      return changeKey(key, $checkbox.prop('checked'));
    });
    $checkbox.prop('checked', config[key]);
    $el = $("<div>").append($("<label>").text(description).append($checkbox));
    return $settings.append($el);
  };

  addSetting('show initial points', "TRACE_INITIAL");

  addSetting('show new horizon', "TRACE_HORIZON");

  addSetting('show horizon search step', "TRACE_HORIZON_STEP");

  addSetting('show new individual faces', "TRACE_NEW_FACE_EACH");

  addSetting('show new face group', "TRACE_NEW_FACES");

  lastKey = null;

  onKeyDown = function(e) {
    var KEYS_END, KEYS_NEXT, KEYS_PREV, KEYS_RESET, KEYS_START, KEY_END, KEY_G, KEY_J, KEY_K, KEY_LEFT, KEY_R, KEY_RIGHT, KEY_START;
    KEY_LEFT = 37;
    KEY_RIGHT = 39;
    KEY_J = "J".charCodeAt(0);
    KEY_K = "K".charCodeAt(0);
    KEY_R = "R".charCodeAt(0);
    KEY_G = "G".charCodeAt(0);
    KEY_END = 35;
    KEY_START = 36;
    KEYS_PREV = [KEY_LEFT, KEY_K];
    KEYS_NEXT = [KEY_RIGHT, KEY_J];
    KEYS_END = [KEY_END];
    KEYS_START = [KEY_START];
    KEYS_RESET = [KEY_R];
    if (_.contains(KEYS_PREV, e.keyCode)) {
      tracer.showPrev();
    }
    if (_.contains(KEYS_NEXT, e.keyCode)) {
      tracer.showNext();
    }
    if (_.contains(KEYS_START, e.keyCode)) {
      tracer.showFirst();
    }
    if (_.contains(KEYS_END, e.keyCode)) {
      tracer.showLast();
    }
    if (_.contains(KEYS_RESET, e.keyCode)) {
      reset();
    }
    if (e.keyCode === KEY_G) {
      if (e.shiftKey) {
        tracer.showLast();
      } else {
        tracer.showFirst();
      }
    }
    return lastKey = e;
  };

  onMouseWheel = function(e) {
    if (e.originalEvent.wheelDeltaY < 0) {
      tracer.showNext();
    }
    if (e.originalEvent.wheelDeltaY > 0) {
      return tracer.showPrev();
    }
  };

  $(window).on('keydown', onKeyDown);

  $(window).on('mousewheel', onMouseWheel);

  reset();

}).call(this);

//# sourceMappingURL=qhull.map
